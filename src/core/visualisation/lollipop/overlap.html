<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>

    <script src="https://code.jquery.com/jquery-3.6.0.min.js"
            integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
    <script type="text/javascript" src="../../../../../../node_modules/@svgdotjs/svg.js/dist/svg.min.js"></script>


</head>
<body>

<div id="circles"></div>
<script>

    const elements = [{id:1, pos: 10, radius: 50}, {id:2, pos: 120, radius: 100}, {id:3, pos: 170, radius: 20}, {id:4, pos: 250, radius: 30}];

    const field_size = [0, 300];

    const min_gap = 0;
    const step = 1;

    let draw = new SVG().addTo("#circles").size(1000, 300);

    draw.rect(300,300).attr({stroke: "#f00", fill: "#fff"})
    let drawPanel;
    // moveIntersected(elements);

    console.log(elements);

    let loopDetector = [];

    function detectCollisions(arr = []) {
        const result = [];
        for (let i = 0; i < arr.length - 1; i++) {
            let dist = (arr[i + 1].pos - arr[i + 1].radius) - (arr[i].pos + arr[i].radius);
            if (dist < min_gap) {
                result.push([i + 0.5, dist]);
            }
        }
        return result;
    }

    function moveIntersected(arr = [], it) {

        if (it > 2000) {
            console.error(it, " iteration exceeded")
            console.log(loopDetector)
            return -1;
        }
        const collisions = detectCollisions(arr);
        if (collisions.length < 1) {
            console.log("collision solved ", it)
            drawCircles()
            return 0;
        }

        const most_intersected = collisions.sort((a, b) => a[1] - b[1])[0];

        console.log("most_intersected", most_intersected)

        const left = arr[Math.floor(most_intersected[0])];
        const right = arr[Math.ceil(most_intersected[0])];

        const currpos = [left.pos, right.pos];
        if (left.pos - left.radius - step >= field_size[0]) {
            left.pos -= step;
        } else {
            // within right boundary
            if (right.pos + right.radius + step * 2 <= field_size[1]) {
                right.pos += step * 2;
            } else {
                //console.error("RIGHT exceeded", right)
            }

        }

        if (right.pos + right.radius + step <= field_size[1]) {
            if (right.pos + right.radius + step < field_size[1]) {
                right.pos += step;
            } else {
                //console.error("RIGHT EXCEEDED", right)
            }
        } else {
            // within left boundary
            if (left.pos - left.radius - step * 2 >= field_size[0]) {
                left.pos -= step * 2;
            } else {
                //console.error("LEFT EXCEEDED", left)
            }
        }
        const newpos = [left.pos, right.pos];
        // loop detection on k = left.id-right.id v="left.pos|right.pos"
        loopDetector.push({k: most_intersected[0], v: `${right.pos-left.pos}`});

        // console.log(left.id, right.id, "currpos, newpos", currpos, newpos)
        if (currpos[0] === newpos[0] && currpos[1] === newpos[1]) {
            console.error("same position!")
            return -1
        }


        return 1;

    }

    function fixBoundaries() {
        elements.forEach(el => {
            console.log(el, el.pos - el.radius)
            if (el.pos - el.radius < field_size[0]) {
                // NOTE offset
                el.pos = field_size[0] + el.radius * 2;
            }
            if (el.pos + el.radius > field_size[1]) {
                // NOTE offset
                el.pos = field_size[1] - el.radius * 2;
            }
        });
    }

    function layout(arr) {

        fixBoundaries();
        let i = 0;
        while (true) {
            // console.log("it", i++);
            const state = moveIntersected(arr, i++);
            if (state === -1) {
                // increase cluster distance
                console.error("no solution");
                break;
            }
            if (state === 0) {
                console.log("collision solved")
                break;
            }

        }
        console.log("layout elements", JSON.stringify(elements))

    }


    function drawCircles() {
        if (drawPanel) {
            drawPanel.clear();
        } else {
            drawPanel = draw.group();
        }
        elements.forEach((el, i) => {
            elements.dom = drawPanel.circle(el.radius * 2)
                .dx(el.pos - el.radius)
                .dy(100-el.radius)
                .fill("#6872ff")
                .stroke({color: "#000", opacity: 0})
                .scale(1);

            /*if (variant.type === "cluster") {
                v.text(variant.variants.length).dy(5).dx(offset).font({size: variant.size * .5 + "px"});
            } else {
                // single variant
                v.text(variant.id).dy(-variant.size / 2 - 5).dx(offset).font({size: "10px"});
            }*/


        });
    }


    drawCircles();
</script>


<button onclick="layout(elements)">layout</button>
</body>
</html>
